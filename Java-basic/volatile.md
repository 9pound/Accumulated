# volatile

volatile 是轻量级的synchronized

#### 特性：

​	1、保证共享变量的可见性：当一个线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的

​	2、禁止指令重排序优化：保证变量的赋值操作的顺序与程序代码中的执行顺序一致，普通的变量仅仅会保证在该方法执行的过程中所有依赖执行结果的地方都能得到正确的值

3、不会引起上下文的切换和调度

4、无法保证原子性

#### 原理：

​	**指令重排序：**CPU允许将多条指令不按程序规定的顺序分发给各个相应的电路单元处理，但并不是任意重排

​	内存屏障：

​	lock前缀：

- 将当前处理器缓存行的数据写回到系统内存
- 这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效（让volatile变量的修改，对其他处理器立即可见）

#### **java内存模型中volatile变量的读写规则：**

1. 每次使用变量V前都必须先从主内存刷新最新的值，用于保证能看见其他线程对变量V所做的修改后的值
2. 每次修改变量V后都必须立刻同步回主内存中，用于保证其他线程可以看到自己对变量V所做的修改
3. volatile修饰的变量，不会被指令重排序优化，保证代码的执行顺序与程序的顺序相同

#### **使用volatile的条件**

1. 运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。
2. 变量不需要与其他变量共同参与不变约束	



**特殊**：volatile变量的运算在并发下是不安全的，因为java中的运算并非原子操作，例如运算符++

使用字节码来分析并发问题是不严谨的，因为即使编译出来只有一条字节码指令，也并不意味执行这条指令就是一个原子操作。

追加字节优化

#### java的内存模型和缓存一致性协议



#### 原子性、可见性、有序性



#### 先行发生原则

FAQ

synchronized 和 volatile 分别是如何保证有序性的？



https://blog.csdn.net/qq_35190492/article/details/105837982

https://www.freesion.com/article/23431337948/

https://www.hollischuang.com/archives/4460