# Java天问—关键字篇

### 1、访问修饰符（access modifier）

|  修饰符   | 当前类 | 同包（子类，非子类） | 不同包，子类 | 不同包，非子类 |
| :-------: | :----: | :------------------: | :----------: | :------------: |
|  public   |  允许  |         允许         |     允许     |      允许      |
| protected |  允许  |         允许         |     允许     |     不允许     |
|  default  |  允许  |         允许         |    不允许    |     不允许     |
|  private  |  允许  |        不允许        |    不允许    |     不允许     |

同包，包含两种情况 

- 1、同包中的子类
- 2、同包中的非子类

简记：

- default：包访问权限
- protected : 子类访问权限，有一个特殊的地方，就是同包中的非子类也可以访问。

### 2、this关键字

this的具体含义：表示对“调用方法的那个对象”的引用，指“这个对象”或者“当前对象”。

**如果你希望在方法内部获得对当前对象的引用，可以使用关键字this**

1、return this ；语句返回对当前对象的引用。
2、将当前对象传递给其他方法
3、在方法的内部调用同一个类的另一个方法，不必使用this关键字，直接调即可。

**在一个构造器中调用另一个构造器**

1、this调用其他构造器的语句，必须是当前构造器中的第一句；
2、在一个构造器中，this一次只能调用另一个构造器，不能同时调用另两个构造器。
3、只能在构造器中使用this调用其他构造器，不能用在方法中。 

**用来区别同名的局部变量和成员变量**

​		

### 3、static关键字

（1）强调只有一份
（2）用来应对两种情况。一种情况是，只想为某特定的域分配单一的存储空间，而不去考虑究竟要创建多少象，甚至根本就不创建任何对象。另一种情况是，希望某个方法不与包含它的类的任何对象关联在一起，也就是说即使没有创建对象，也能够调用这个方法
（3）当声明一个事物是static时，就意味着这个域或方法不会与包含它的那个类的任何对实例关联在一起。

**static方法**（又称为类方法）

（1）static方法就是没有this的方法 

（2）在static方法内部不能调用非静态方法，反过来倒是可以。也不能访问实例域，但是可以访问自身类中的静态域

（3）.如果某个方法是静态的，它的行为就不具有多态性。

**static域**（又称为类变量）

（1）当static作用于域时，会改变数据创建的方式。一个static的域对每个类来说都只有
一份存储空间，而非static域或者说成员变量则是对每个对象都有一个存储空间。也就说
一个类的所有的对象都共享static的域。
（2）可以在没有创建任何对象的前提下，仅仅通过类名来访问本类的static方法或域

**静态初始化块**
	

static {} 用来对类中的静态域进行初始化。

**静态内部类（嵌套类）**
	

1、如果不需要内部类对象与其外围类对象之间有联系，那么可以将内部类声明为static
2、普通的内部类对象隐式地保存了一个引用，指向创建它的外围类对象。普通内部类不有
static数据和static字段。
3、使用static内部类的条件
	（1）要创建嵌套类的对象，并不需要其外围类的对象
	（2）不能从嵌套类的对象中访问非静态的外围类

### 4、final关键字

通常的含义是：这是无法改变的，

**final数据**
	

（1）编译时常量
	1、这类常量必须是基本数据类型，并且以关键字final表示
	2、在对这个常量进行定义的时候，必须对其进行赋值
（2）final引用
	1、对于基本类型，final使数值恒定不变。而对于对象引用，final使引用恒定变。
	具体含义是：一旦这个final的引用被初始化指向一个对象，就无法再把它改为指另
	一个对象。然而，对象其自身确是可以被修改的、
（3）补充：
	1、一个既是static又是final的域（成员变量）占据一段不能改变的存储空间（根
	据惯例,既是static又是final的成员变量用大写表示，并使用下划线分隔各个词）
	2、必须确保在每一个构造器执行之后（类的初始化过程中），这个final域被初始化，并且在后
	面的操作中不能够再对它进行修改
	3、将final数值定义为静态和非静态的区别:这种区别只有当数值在运行时被初始时
	才会显现。具体区别如下：static 的final值，在类装载时已经被初始化，初始化
	动作只发生一次。而单纯的final值是每次创建新的对象时都会被重新初始化，初始化
	动作发生了多次。

**空白final**
	

（1）含义：被声明为final但又未给定初值的域（成员变量）
（2）必须在空final域的定义处或者"每个"构造器中用表达式对final域进行赋值。（这
是final域在使用时总是被初始化的原因）

**final参数**

（1）含义：你无法在方法中更改参数引用所指向的对象
（2）用途：用来向匿名内部类传递数据

**final方法**

（1）为什么需要final方法：原因一，把方法锁定，以防任何继承类修改它的含义，确保
在继承中使方法行为保持不变，并且不会被覆盖。原因二：出于效率，早期的Java实现中，
把一个方法指明为final，就是同意编译器针对该方法的所有调用都转为内嵌调用。
（2）忠告：不建议为了效率将方法声明为final的，只有在想要明确禁止覆盖是，才将方 
法设置为final的。
（3）补充：
	1、类中所有的private方法法都隐式地指定为是final的。这也是private方法无法被覆盖的原因
	2、final方法不具有多态性，final关键字告诉编译器不许要对这个方法进行动态绑定
（4）提高：基类中的private方法，可以在导出类中，用public，protected，默认包
访问权限，声明一个同名方法，达到覆盖的假象。（原因详见java编程思想第四版p144）		

**final类**

1. （1）含义：表明你不打算继承该类，或者说final类禁止继承。
2. 注意：final类的域（成员变量）可以声明为final，也可以不声明为final
3. 注意：final类中所有的方法都隐式指定为final的，因为final类无法被继承，方法也就无法被覆盖。可以给方法添加final修饰词，但是这不会增加任何意义。
4. 如果一个类声明为final，只有其中的方法自动地成为final的，而不包括域


### 5、super关键字 ###
**调用超类的构造器**

在导出类的构造器主体中，如果没有明确指定调用基类的构造器，编译器就会“默默”地调用
基类的默认构造器（若某个类没有构造器，编译器会自动合成一个默认的构造器），如果不
存在默认构造器，编译器就会报错（）。

#### 6、