# 消费者

消费者

消费者群组

- 一个群组的消费者订阅的是同一个主题，每个消费者接收主题一部分分区的消息 
- 如果群组里消费者的数量超过主题分区的数量，那么有一部分消费者就会被闲置，不会接收到任何消息
- 多个应用程序可以从同一个主题读取数据

横向伸缩： 增加更多的消费者

群主:

第一个加入群组的消费者

群组从协调器那里获得群组的成员列表，并负责给每一个消费者分配分区

分配完毕之后，群主把分配情况列表发送给群组协调器，协调器再把这些信息发送给所有消费者

##### 再均衡

分区的所有权从一个消费者转移到另一个消费者的行为。

如果消费者停止发送心跳的时间足够长，回话就会过期，群组协调器认为它已经死亡，就会触发再均衡。



API

kafkaConsumer 

​	bootstrap.servers : kafka集群的连接字符串

​	key.deserializer：使用指定类把Java字节数组转成Java对象

​	value.deserializer：

​	group.id : 非必须，指定KafkaConsumer 属于哪一个消费者群组。可以创建一个不属于任何群组的消费者



消息轮询

一旦消费者订阅了主题，轮询就会处理所有的细节，包括群组协调，分区再均衡，发送心跳和获取数据

消费者必须持续对kafka进行轮询，否则会被认为死亡，它的分区会被移交给群组里的其他消费者。



提交

我们把更新分区当前位置的操作叫做提交

​	消费者往一个叫做_consumer_offset 的特殊主题发送消息，消息里包含每个分区的偏移量

# FAQ？

生产者往主题写入消息的速度超过了应用程序验证数据的速度，这个时候该怎么办

使用多个消费者从同一个主题读取消息，对消息进行分流



一个分区只有一个消费者吗？

一个分区只能分给一个群组里的一个消费者，消费者与分区一对多



kafka不会像其他jms队列那样需要得到消费者的确认