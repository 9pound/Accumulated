# Innodb

## 插入缓冲（Insert Buffer)

InnoDB存储引擎开创性地设计了Insert Buffer，对于非聚集索引的插人或更新操作，不是每一次直接插人到索引页中，而是先判断插入的非聚集索引页是否在缓冲池中，若在，则直接插人﹔若不在，则先放人到一个Insert Buffer对象中，好似欺骗。数据库这个非聚集的索引已经插到叶子节点，而实际并没有，只是存放在另一个位置。然后再以一定的频率和情况进行Insert Buffer 和辅助索引页子节点的merge（合并）操作，这时通常能将多个插人合并到一个操作中（因为在一个索引页中)，这就大大提高了对于非聚集索引插人的性能。然而Insert Buffer的使用需要同时满足以下两个条件:

- 索引是辅助索引(secondary index);
- 索引不是唯一 (unique）的。



## 两次写（Double Write)

现过因为部分写失效而导致数据丢失的情况。当发生数据库宕机时，可能InnoDB存储引擎正在写人某个页到表中，而这个页只写了一部分，比如16KB的页，只写了前4KB，之后就发生了宕机，这种情况被称为部分写失效(partial page write)。在InnoDB存储引擎未使用doublewrite技术前，曾经出现过因为部分写失效而导致数据丢失的情况。




有经验的DBA也许会想，如果发生写失效，可以通过重做日志进行恢复。这是一个办法。但是必须清楚地认识到，重做日志中记录的是对页的物理操作，如偏移量800，写'aaaa'记录。如果这个页本身已经发生了损坏，再对其进行重做是没有意义的。这就是说，在应用（apply）重做日志前，用户需要一个页的副本，当写人失效发生时，先通过页的副本来还原该页，再进行重做，这就是doublewrite。在InnoDB存储引擎中



## 自适应哈希索引(Adaptive Hash Index)

哈希（hash）是一种非常快的查找方法，在一般情况下这种查找的时间复杂度为o(1)，即一般仅需要一次查找就能定位数据。而B+树的查找次数，取决于B+树的高InnoDB存储引擎会监控对表上各索引页的查询。如果观察到建立哈希索引可以带来速度提升，则建立哈希索引，称之为自适应哈希索引（Adaptive Hash Index，AHI)。AHI是通过缓冲池的B+树页构造而来，因此建立的速度很快，而且不需要对整张表构建哈希索引。InnoDB存储引擎会自动根据访问的频率和模式来自动地为某些热点页建立



- 以该模式访问了100次
- 页通过该模式访问了N次，其中N=页中记录*1/16

设计思想是数据库自优化的（self-tuning)，即无需DBA对数据库进行人为调整。根据InnoDB存储引擎官方的文档显示，启用AHI后，读取和写入速度可以提高2倍，辅助索引的连接操作性能可以提高5倍。毫无疑问，AHI是非常好的优化模式，



## 异步IO (Async IO)AIO）的方式来处理磁盘操作。

InnoDB存储引擎亦是如此。样可以提高IOPS的性能。例如用户需要访问页的space，page_no）为:为了提高磁盘操作性能，当前的数据库系统都采用异步IO(Asynchronous IO,与AIO对应的是Sync IO，即每进行一次IO操作，需要等待此次操作结束才能继续接下来的操作是如果用户发出的是一条索引扫描的查询，那么这条SQL查询语句可能需要扫描多个索引页，也就是需要进行多次的IO操作。在每扫描一个页并等待其完成后再进行下一次的扫描，这是没有必要的。用户可以在发出一个IO请求后立即再发AIO的另一个优势是可以进行IO Merge操作，也就是将多个I0合并为1个IO，这出另一个IO请求，当全部IO请求发送完毕后，等待所有IO操作的完成，这就是AIO

## 刷新邻接页（Flush Neighbor Page）


InnoDB存储引擎还提供了Flush Neighbor Page（刷新邻接页）的特性。其工作原理为:当刷新一个脏页时，InnoDB存储引擎会检测该页所在区（extent）的所有页，如果是脏页，那么一起进行刷新。这样做的好处显而易见，通过AIO可以将多个IO写人操作合并为一个I0操作，故该工作机制在传统机械磁盘下有着显著的优势。但是需要考用来控制是否启用该特性。对于传统机械硬盘建议启用该特性，而对于固态硬盘有着超高为此，InnoDB存储引擎从1.2.x版本开始提供了参数innodb_flush_neighbors,

虑到下面两个问题:
是不是可能将不怎么脏的页进行了写人，而该页之后又会很快变成脏页?
固态硬盘有着较高的IOPS，是否还需要这个特性?
IOPS性能的磁盘，则建议将该参数设置为0，即关闭此特性。