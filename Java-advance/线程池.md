# 线程池

#### 为什么要用线程池

本质上就是为了线程复用



因为不能无限的创建线程、在一定的范围内，增加线程可以提高系统的吞吐率，但如果超出了这个范围，再创建更多的线程只会降低程序的执行速度，如果过多的创建一个线程，那么整个应用程序将会崩溃。

- 线程生命周期的开销非常高
- 资源消耗：闲置的线程会占用内存
- 稳定性：

#### **什么时候使用线程池**

1、程序创建了大量的生命周期很短的线程

2、减少并发线程的数目

好处：

​	分摊线程创建和销毁过程中的巨大开销，

​	不会由于等待创建线程而延迟任务的执行，从而提高响应性

## Executor

**原理**：基于生产者消费者模式

##### 生命周期

​	之前提交任务的状态不是立即可见的，有些任务可能已经完成，有些可能正在运行，而其他任务可能在队列中等待执行

**常用的线程池**

- newCachedThreadPool
  - 对于每个任务，如果有空闲线程可以用，立即让它执行任务，如果没有可用的空闲线程，则创建一个新的线程
- newFixedThreadPool
  - 构建一个具有固定大小的线程池。如果提交的任务数多于空闲的线程，那么把得不到服务的任务放置到队列中，当其他任务完成以后再运行它们
- newSingleThreadExecutor
  - 由一个线程池执行提交的任务，一个接着一个

- newScheduledThreadPool


​	固定长度的线程池、可以以延时或定时的方式来执行任务

#### **使用线程池的基本步骤**

1、调用Executors类中的静态方法

2、调用submit提交Runnable或Callable对象

3、如果想要取消一个任务，或如果提交Callable对象，那就要保存好返回的Future对象

4、当不再提交任何任务时，调用shutdown

## ExecutorService

为了解决声明周期问题

生命周期：运行、关闭、已终止

shutdown() ：平缓的关闭过程、不再接受新的任务，同时等待已经提交了的任务执行完成（包括哪些还未开始执行的任务）

shutdownNow()：粗暴的关闭过程、尝试取消所有运行中的任务，并且不再启动队列中尚未开始执行的任务



## ThreadPoolExecutor

execute方法







## 控制任务组

使用线程池控制一组相关的任务

shutdownNow

invokeAny



# 

# Fork-Join框架

# 可完成Future

# FAQ

#### this逃逸问题？

#### Runnable与Callable有什么区别？

execute()方法与submit()方法有什么区别？

shutdown()方法与shutdownNow（）方法有什么区别

isTerminated和isShutdown方法的区别

