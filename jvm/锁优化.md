# 锁优化

#### 自旋锁/自适应自旋

**特点**

- 避免线程切换开销
- 占用处理器时间

-xx：+UseSpinning

-xx：preBlockSpin

#### 锁消除

- 如果一段代码中，在堆上的所有数据都不会逃逸出去从而被其他线程访问到，那就可以吧它们当成栈上的数据对待，认为它们是线程私有的，同步加锁自然就无需进行

#### 锁粗化

如果虚拟机探测到有这样一串零碎的操作都对同一个对象加锁，将会把加锁同步的范围扩展到整个操作序列的外部

#### 轻量级锁

避免使用互斥量的开销，在无竞争的情况下使用CAS操作去消除同步使用的互斥量

**MarkWord**

- 对象HashCode
- GC分代年龄
- 锁标志

**加锁过程**

- 在代码进入同步块的时候，如果此同步对象没有被锁定（锁标志位是01）虚拟机在当前线程的栈帧中建立一个名为锁记录的空间，锁记录用于存储对象目前的MarkWord拷贝
- 然后虚拟机将使用CAS操作尝试将对象的MARKWord更新为指向LockRecord的指针，如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，对象的MarkWord的锁标志位变为00。如果更新操作失败了，虚拟机检查对象的MarkWord是否指向当前线程的栈帧，如果只说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明这个对象已经被其他线程抢占了，
- 如果有**两条以上的线程**竞争同一个锁，那轻量级锁就不在有效，膨胀为重量级锁，所标志位变成10，MarkWord 中存储指向重量级锁（互斥量）的指针，后面等待的线程进入阻塞状态

**解锁过程**

- 如果对象的MarkWord任然指向着线程的锁记录，那就用CAS操作把对象当前的MarkWord和线程中复制的Displaced Mark Word替换回来，如果替换成功，整个同步过程就完成了。如果替换失败说明有其他线程尝试获取该锁，那就要在释放锁的同时，唤醒被挂起的线程

#### 偏向锁

- 消除数据在无竞争情况下的同步原语，在无竞争的情况下把整个同步都消除掉
- 偏向锁会偏向于第一个获取它的线程，
- -XX：useBiasedLocking

**加锁的过程**

- 当锁对象第一次被线程获取的时候，虚拟机将会把对象头中的标志位设置为01，同时使用CAS操作把获取到这个锁的线程ID记录在对象的MarkWord之中，如果CAS成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不在进行任何同步操作

**解锁过程**

- 当有**另外一个线程**尝试去获取这个锁时，偏向模式结束。根据对象目前是否处于被锁定的状态，恢复到未锁定或轻量级锁的状态